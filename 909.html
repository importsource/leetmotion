<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LeetCode 909: Snakes and Ladders Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .code-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .code-scroll::-webkit-scrollbar-track {
            background: #1e293b;
        }
        .code-scroll::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        .code-scroll::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .cell-transition {
            transition: background-color 300ms ease-in-out;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.555.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
<body class="bg-slate-50 text-slate-800 font-sans min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-white shadow-sm p-4 border-b">
        <div class="max-w-6xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4">
            <h1 class="text-xl font-bold flex items-center gap-2">
                <span class="bg-blue-600 text-white p-1 rounded">909</span>
                Snakes and Ladders Visualization
            </h1>
            <a href="https://importsource.github.io/leetmotion/" target="_blank" rel="noreferrer"
                class="text-sm text-blue-600 hover:text-blue-800 flex items-center gap-1 font-medium transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36.5-8 0C6.72 2.75 4.14 1.75 2 4.75c-.28 1.15-.28 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4" />
                    <path d="M9 18c-4.51 2-5-2-7-2" />
                </svg>
                Wait, checkout LeetMotion
            </a>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 max-w-6xl mx-auto w-full p-4 md:p-8 grid grid-cols-1 lg:grid-cols-2 gap-8">
        
        <!-- Left Column: Board & Controls -->
        <div class="flex flex-col gap-6">
            <!-- Board Wrapper -->
            <div class="bg-white p-4 rounded-xl shadow-lg border border-slate-100">
                <div class="relative w-full max-w-md aspect-square mx-auto">
                    <!-- Grid -->
                    <div id="board-grid" class="grid w-full h-full" style="grid-template-columns: repeat(6, 1fr); grid-template-rows: repeat(6, 1fr);">
                        <!-- Cells will be generated here -->
                    </div>
                    <!-- SVG Overlay for Snakes/Ladders -->
                    <svg id="board-overlay" class="absolute inset-0 w-full h-full pointer-events-none z-20">
                        <!-- Lines will be generated here -->
                    </svg>
                </div>
            </div>

            <!-- Controls Panel -->
            <div class="bg-white p-6 rounded-xl shadow border border-slate-100 flex flex-col gap-4">
                <div class="flex items-center justify-between">
                    <div class="font-semibold text-slate-600">Controls</div>
                    <div class="text-sm text-slate-400">Step Delay: <span id="speed-display">500</span>ms</div>
                </div>

                <div class="flex items-center gap-4">
                    <button id="btn-play" class="flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-medium transition-all active:scale-95">
                        <span id="icon-play" class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                            Play
                        </span>
                        <span id="icon-pause" class="hidden flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                            Pause
                        </span>
                    </button>

                    <button id="btn-step" class="flex items-center justify-center gap-2 bg-slate-100 hover:bg-slate-200 text-slate-700 px-4 py-2 rounded-lg font-medium transition-all">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/></svg>
                        Step
                    </button>

                    <button id="btn-reset" class="flex items-center justify-center gap-2 bg-slate-100 hover:bg-slate-200 text-slate-700 px-4 py-2 rounded-lg font-medium transition-all ml-auto">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        Reset
                    </button>
                </div>

                <input id="input-speed" type="range" min="50" max="2000" value="500" class="w-full accent-blue-600 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>

        <!-- Right Column: Code & State -->
        <div class="flex flex-col gap-6">
            <!-- Info Panel -->
            <div class="bg-white p-6 rounded-xl shadow border border-slate-100 min-h-[120px]">
                <h3 class="text-sm font-semibold text-slate-400 uppercase tracking-wider mb-2">Current Operation</h3>
                <div id="status-description" class="text-lg font-medium text-slate-800">
                    Initializing...
                </div>
                <div class="mt-4 flex gap-4 text-sm">
                    <div class="bg-slate-50 px-3 py-1 rounded border">
                        Steps: <span id="stat-steps" class="font-bold text-blue-600">0</span>
                    </div>
                    <div class="bg-slate-50 px-3 py-1 rounded border">
                        Queue Size: <span id="stat-queue" class="font-bold text-blue-600">0</span>
                    </div>
                    <div id="stat-result" class="hidden px-3 py-1 rounded border font-bold"></div>
                </div>
            </div>

            <!-- Code Panel -->
            <div class="bg-slate-900 text-slate-100 rounded-lg overflow-hidden flex flex-col h-96 shadow-xl">
                <div class="bg-slate-800 px-4 py-2 text-xs font-mono border-b border-slate-700">
                    Solution.java
                </div>
                <div id="code-container" class="flex-1 overflow-auto p-4 font-mono text-xs code-scroll relative">
                    <!-- Code lines injected here -->
                </div>
            </div>

            <!-- Legend -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs text-slate-600 p-4 bg-white rounded-xl border border-slate-100">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-blue-500 rounded-sm"></div> Current
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-yellow-200 rounded-sm"></div> Next Check
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-green-400 rounded-sm"></div> Destination
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-slate-300 rounded-sm"></div> Visited
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-blue-200 rounded-sm"></div> In Queue
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-8 h-1 bg-red-500 opacity-60"></div> Snake
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-8 h-1 bg-green-500 opacity-60"></div> Ladder
                </div>
            </div>
        </div>

    </main>

    <!-- Application Logic -->
    <script>
        /**
         * Constants & Config
         */
        const JAVA_CODE = `class Solution {
    public int snakesAndLadders(int[][] board) {
        int n = board.length;

        // Step 1: Create a 1-D array to represent the board from 1 -> n*n.
        // Because the board is numbered in a zig-zag fashion, we must map correctly.
        int[] flat = new int[n * n + 1];

        int index = 1;               // 'index' represents the current square number (1-based).
        boolean leftToRight = true;  // Every row alternates direction.

        // Traverse from bottom row to top row because the game board starts at bottom-left.
        for (int r = n - 1; r >= 0; r--) {

            if (leftToRight) {
                // If row direction is left → right
                for (int c = 0; c < n; c++) {
                    flat[index++] = board[r][c];
                }
            } else {
                // If row direction is right → left
                for (int c = n - 1; c >= 0; c--) {
                    flat[index++] = board[r][c];
                }
            }

            // Reverse direction for next row
            leftToRight = !leftToRight;
        }

        // Step 2: BFS from square 1 to square n*n.
        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[n * n + 1];

        queue.offer(1);      // Start from square 1
        visited[1] = true;
        int steps = 0;       // Number of dice rolls

        while (!queue.isEmpty()) {
            int size = queue.size();

            // Each loop = one dice roll
            for (int i = 0; i < size; i++) {
                int curr = queue.poll();

                // If we reach last square -> return steps
                if (curr == n * n) {
                    return steps;
                }

                // Try dice rolls: 1 to 6
                for (int move = 1; move <= 6; move++) {
                    int next = curr + move;

                    // Don't exceed board
                    if (next > n * n) break;

                    // If this square has a snake/ladder
                    if (flat[next] != -1) {
                        next = flat[next];  // Jump to the destination square
                    }

                    // Only process unvisited squares
                    if (!visited[next]) {
                        visited[next] = true;
                        queue.offer(next);
                    }
                }
            }

            // Increase dice roll count after exploring one full BFS level
            steps++;
        }

        // If queue empties and no path found:
        return -1;
    }
}`;

        const CODE_LINES = {
            INIT: 35, // queue.offer(1)
            WHILE: 39, // while (!queue.isEmpty())
            POLL: 43, // int curr = queue.poll()
            CHECK_TARGET: 46, // if (curr == n * n)
            LOOP_MOVES: 51, // for (int move = 1...
            CHECK_SNAKE: 58, // if (flat[next] != -1)
            APPLY_SNAKE: 59, // next = flat[next]
            CHECK_VISITED: 63, // if (!visited[next])
            ADD_QUEUE: 65, // queue.offer(next)
            INC_STEPS: 71, // steps++
            RETURN_FOUND: 47, // return steps
            RETURN_NOT_FOUND: 75 // return -1
        };

        const DEFAULT_BOARD_SIZE = 6;
        
        // Logical map: Start -> End
        const LADDERS_SNAKES_MAP = {
            2: 15, 5: 7, 9: 27, 18: 29, 25: 35, // Ladders
            17: 4, 20: 6, 24: 16, 32: 30, 34: 12 // Snakes
        };

        /**
         * Logic Utilities
         */
        const getCellCoordinates = (index, n) => {
            // Returns logical row, col (0-based, from top-left)
            // Calculate row from bottom (0 is bottom)
            const rFromBottom = Math.floor((index - 1) / n);
            // Real row index (0 is top)
            const r = n - 1 - rFromBottom;

            let c = (index - 1) % n;
            // If row from bottom is odd (1, 3, 5...), direction is Right -> Left
            if (rFromBottom % 2 === 1) {
                c = n - 1 - c;
            }
            return { r, c };
        };

        const generateFlatBoard = (n, map) => {
            const flat = new Array(n * n + 1).fill(-1);
            Object.entries(map).forEach(([start, end]) => {
                flat[Number(start)] = Number(end);
            });
            return flat;
        };

        // Generator function for BFS step-by-step
        function* bfsGenerator(n, flatBoard) {
            const queue = [];
            const visited = new Array(n * n + 1).fill(false);
            let steps = 0;

            queue.push(1);
            visited[1] = true;

            yield {
                queue: [...queue],
                visited: [...visited],
                curr: null,
                nextCheck: null,
                nextFinal: null,
                steps: 0,
                activeLine: CODE_LINES.INIT,
                description: "Initialize Queue with square 1. Mark 1 as visited.",
                isFinished: false
            };

            while (queue.length > 0) {
                yield {
                    queue: [...queue],
                    visited: [...visited],
                    curr: null,
                    nextCheck: null,
                    nextFinal: null,
                    steps,
                    activeLine: CODE_LINES.WHILE,
                    description: `Start level ${steps}. Queue size: ${queue.length}`,
                    isFinished: false
                };

                const size = queue.length;
                for (let i = 0; i < size; i++) {
                    const curr = queue.shift();

                    yield {
                        queue: [...queue],
                        visited: [...visited],
                        curr,
                        nextCheck: null,
                        nextFinal: null,
                        steps,
                        activeLine: CODE_LINES.POLL,
                        description: `Poll current square: ${curr}`,
                        isFinished: false
                    };

                    if (curr === n * n) {
                        yield {
                            queue: [...queue],
                            visited: [...visited],
                            curr,
                            nextCheck: null,
                            nextFinal: null,
                            steps,
                            activeLine: CODE_LINES.RETURN_FOUND,
                            description: `Reached target ${n * n}! Total steps: ${steps}`,
                            isFinished: true,
                            foundPath: steps
                        };
                        return;
                    }

                    // Try moves 1-6
                    for (let move = 1; move <= 6; move++) {
                        let next = curr + move;

                        yield {
                            queue: [...queue],
                            visited: [...visited],
                            curr,
                            nextCheck: next,
                            nextFinal: null,
                            steps,
                            activeLine: CODE_LINES.LOOP_MOVES,
                            description: `Roll ${move}: Check square ${next}`,
                            isFinished: false
                        };

                        if (next > n * n) break;

                        const isSnakeOrLadder = flatBoard[next] !== -1;

                        if (isSnakeOrLadder) {
                            yield {
                                queue: [...queue],
                                visited: [...visited],
                                curr,
                                nextCheck: next,
                                nextFinal: null,
                                steps,
                                activeLine: CODE_LINES.CHECK_SNAKE,
                                description: `Square ${next} has a ${flatBoard[next] > next ? 'ladder' : 'snake'}!`,
                                isFinished: false
                            };

                            next = flatBoard[next];

                            yield {
                                queue: [...queue],
                                visited: [...visited],
                                curr,
                                nextCheck: null,
                                nextFinal: next,
                                steps,
                                activeLine: CODE_LINES.APPLY_SNAKE,
                                description: `Jump to square ${next}`,
                                isFinished: false
                            };
                        }

                        if (!visited[next]) {
                            visited[next] = true;
                            queue.push(next);

                            yield {
                                queue: [...queue],
                                visited: [...visited],
                                curr,
                                nextCheck: null,
                                nextFinal: next,
                                steps,
                                activeLine: CODE_LINES.ADD_QUEUE,
                                description: `Add ${next} to queue and mark visited`,
                                isFinished: false
                            };
                        } else {
                            yield {
                                queue: [...queue],
                                visited: [...visited],
                                curr,
                                nextCheck: null,
                                nextFinal: next,
                                steps,
                                activeLine: CODE_LINES.CHECK_VISITED,
                                description: `Square ${next} already visited. Skip.`,
                                isFinished: false
                            };
                        }
                    }
                }
                steps++;
                yield {
                    queue: [...queue],
                    visited: [...visited],
                    curr: null,
                    nextCheck: null,
                    nextFinal: null,
                    steps,
                    activeLine: CODE_LINES.INC_STEPS,
                    description: `Level finished. Increment steps to ${steps}`,
                    isFinished: false
                };
            }

            yield {
                queue: [...queue],
                visited: [...visited],
                curr: null,
                nextCheck: null,
                nextFinal: null,
                steps,
                activeLine: CODE_LINES.RETURN_NOT_FOUND,
                description: "Queue empty. No path found.",
                isFinished: true,
                foundPath: -1
            };
        }

        /**
         * Application State & Initialization
         */
        let isPlaying = false;
        let speed = 500;
        let timerId = null;
        let generator = null;
        let currentState = null;
        const flatBoard = generateFlatBoard(DEFAULT_BOARD_SIZE, LADDERS_SNAKES_MAP);

        // Pre-calculate cell positions for rendering
        const cellMap = [];
        for (let i = 1; i <= DEFAULT_BOARD_SIZE * DEFAULT_BOARD_SIZE; i++) {
            cellMap[i] = getCellCoordinates(i, DEFAULT_BOARD_SIZE);
        }

        // DOM Elements
        const elGrid = document.getElementById('board-grid');
        const elOverlay = document.getElementById('board-overlay');
        const elCodeContainer = document.getElementById('code-container');
        const elDescription = document.getElementById('status-description');
        const elStatSteps = document.getElementById('stat-steps');
        const elStatQueue = document.getElementById('stat-queue');
        const elStatResult = document.getElementById('stat-result');
        const btnPlay = document.getElementById('btn-play');
        const btnStep = document.getElementById('btn-step');
        const btnReset = document.getElementById('btn-reset');
        const iconPlay = document.getElementById('icon-play');
        const iconPause = document.getElementById('icon-pause');
        const inputSpeed = document.getElementById('input-speed');
        const displaySpeed = document.getElementById('speed-display');

        /**
         * Rendering Functions
         */
        function initBoard() {
            // Generate Grid Cells
            let html = '';
            for (let i = 0; i < DEFAULT_BOARD_SIZE * DEFAULT_BOARD_SIZE; i++) {
                // The grid iterates 0..35 top-left to bottom-right
                // We need to find which logic number (1..36) corresponds to this physical slot
                const r = Math.floor(i / DEFAULT_BOARD_SIZE);
                const c = i % DEFAULT_BOARD_SIZE;
                
                // Reverse lookup: find index where cellMap[index] == {r, c}
                let logicIdx = -1;
                for(let idx=1; idx < cellMap.length; idx++) {
                    if (cellMap[idx].r === r && cellMap[idx].c === c) {
                        logicIdx = idx;
                        break;
                    }
                }
                
                const isSnakeHead = LADDERS_SNAKES_MAP[logicIdx] && LADDERS_SNAKES_MAP[logicIdx] < logicIdx;
                const isLadderBase = LADDERS_SNAKES_MAP[logicIdx] && LADDERS_SNAKES_MAP[logicIdx] > logicIdx;
                
                let icon = '';
                if(isSnakeHead) {
                     // Down Arrow
                     icon = `<svg class="absolute text-red-500 opacity-20 w-8 h-8" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>`;
                } else if(isLadderBase) {
                     // Up Arrow
                     icon = `<svg class="absolute text-green-500 opacity-20 w-8 h-8" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>`;
                }

                html += `<div id="cell-${logicIdx}" class="cell-transition relative border border-slate-300 flex items-center justify-center font-bold text-sm bg-slate-100 h-full">
                    <span class="z-10">${logicIdx}</span>
                    ${icon}
                </div>`;
            }
            elGrid.innerHTML = html;

            // Generate Overlay Snakes/Ladders
            let svgHtml = '';
            Object.entries(LADDERS_SNAKES_MAP).forEach(([startStr, endStr]) => {
                const start = Number(startStr);
                const end = Number(endStr);
                const startPos = cellMap[start];
                const endPos = cellMap[end];

                const x1 = (startPos.c + 0.5) * (100 / DEFAULT_BOARD_SIZE);
                const y1 = (startPos.r + 0.5) * (100 / DEFAULT_BOARD_SIZE);
                const x2 = (endPos.c + 0.5) * (100 / DEFAULT_BOARD_SIZE);
                const y2 = (endPos.r + 0.5) * (100 / DEFAULT_BOARD_SIZE);

                const isSnake = start > end;
                const color = isSnake ? 'red' : 'green';

                svgHtml += `
                    <line x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%" 
                          stroke="${color}" stroke-width="4" stroke-opacity="0.6" stroke-linecap="round" />
                    <circle cx="${x2}%" cy="${y2}%" r="1.5%" fill="${color}" opacity="0.8" />
                `;
            });
            elOverlay.innerHTML = svgHtml;
        }

        function initCodePanel() {
            const lines = JAVA_CODE.split('\n');
            let html = '';
            lines.forEach((line, idx) => {
                const lineNum = idx + 1;
                html += `<div id="code-line-${lineNum}" class="flex px-4 border-l-4 border-transparent">
                    <span class="text-slate-500 w-8 flex-shrink-0 select-none text-right pr-3">${lineNum}</span>
                    <pre class="whitespace-pre">${line}</pre>
                </div>`;
            });
            elCodeContainer.innerHTML = html;
        }

        function renderState(state) {
            // Update Board Cells
            for (let i = 1; i <= DEFAULT_BOARD_SIZE * DEFAULT_BOARD_SIZE; i++) {
                const el = document.getElementById(`cell-${i}`);
                if (!el) continue;

                // Determine color class
                let className = "cell-transition relative border border-slate-300 flex items-center justify-center font-bold text-sm h-full ";
                
                if (state.curr === i) {
                    className += "bg-blue-500 text-white";
                } else if (state.nextCheck === i) {
                    className += "bg-yellow-200";
                } else if (state.nextFinal === i) {
                    className += "bg-green-400";
                } else if (state.visited[i]) {
                    className += "bg-slate-300";
                } else if (state.queue.includes(i)) {
                    className += "bg-blue-200";
                } else {
                    className += "bg-slate-100";
                }
                
                el.className = className;
            }

            // Update Info
            elDescription.textContent = state.description;
            elStatSteps.textContent = state.steps;
            elStatQueue.textContent = state.queue.length;

            if (state.isFinished) {
                elStatResult.classList.remove('hidden');
                if (state.foundPath !== -1) {
                    elStatResult.textContent = 'Path Found!';
                    elStatResult.className = 'px-3 py-1 rounded border font-bold bg-green-100 text-green-700 border-green-200';
                } else {
                    elStatResult.textContent = 'No Path';
                    elStatResult.className = 'px-3 py-1 rounded border font-bold bg-red-100 text-red-700 border-red-200';
                }
            } else {
                elStatResult.classList.add('hidden');
            }

            // Update Code Highlight
            // Remove old highlight
            const oldActive = elCodeContainer.querySelector('.bg-blue-900\\/50');
            if (oldActive) {
                oldActive.classList.remove('bg-blue-900/50', '-mx-4', 'border-blue-500');
                oldActive.classList.add('px-4', 'border-transparent');
            }
            
            // Add new highlight
            const newActive = document.getElementById(`code-line-${state.activeLine}`);
            if (newActive) {
                newActive.classList.remove('px-4', 'border-transparent');
                newActive.classList.add('bg-blue-900/50', '-mx-4', 'border-blue-500');
                newActive.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        /**
         * Game Control Logic
         */
        function resetGame() {
            stopTimer();
            setIsPlaying(false);
            generator = bfsGenerator(DEFAULT_BOARD_SIZE, flatBoard);
            const next = generator.next();
            if (!next.done) {
                currentState = next.value;
                renderState(currentState);
            }
        }

        function stepGame() {
            if (!generator) return;
            const next = generator.next();
            if (next.done) {
                setIsPlaying(false);
                stopTimer();
            } else {
                currentState = next.value;
                renderState(currentState);
            }
        }

        function startTimer() {
            if (timerId) return;
            timerId = setInterval(stepGame, speed);
        }

        function stopTimer() {
            if (timerId) {
                clearInterval(timerId);
                timerId = null;
            }
        }

        function setIsPlaying(playing) {
            isPlaying = playing;
            if (playing) {
                iconPlay.classList.add('hidden');
                iconPause.classList.remove('hidden');
                btnStep.disabled = true;
                btnStep.classList.add('opacity-50');
            } else {
                iconPlay.classList.remove('hidden');
                iconPause.classList.add('hidden');
                btnStep.disabled = currentState?.isFinished;
                if (!currentState?.isFinished) btnStep.classList.remove('opacity-50');
            }
        }

        function togglePlay() {
            if (isPlaying) {
                stopTimer();
                setIsPlaying(false);
            } else {
                if (currentState?.isFinished) resetGame(); // Auto restart if done
                
                setIsPlaying(true);
                startTimer();
            }
        }

        /**
         * Event Listeners
         */
        btnPlay.addEventListener('click', togglePlay);
        
        btnStep.addEventListener('click', () => {
            setIsPlaying(false);
            stopTimer();
            stepGame();
        });

        btnReset.addEventListener('click', resetGame);

        inputSpeed.addEventListener('input', (e) => {
            speed = Number(e.target.value);
            displaySpeed.textContent = speed;
            if (isPlaying) {
                stopTimer();
                startTimer();
            }
        });

        // Initialize
        initBoard();
        initCodePanel();
        resetGame();

    </script>
</body>
</html>