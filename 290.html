<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 290: Word Pattern Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .transition-all-300 { transition: all 0.3s ease-in-out; }
        .cell-appear { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.5); }
            100% { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 min-h-screen flex flex-col">

    <!-- Navbar -->
    <nav class="bg-white border-b border-slate-200 px-6 py-4 flex justify-between items-center sticky top-0 z-50">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-indigo-600 rounded-lg flex items-center justify-center text-white font-bold">
                290
            </div>
            <h1 class="text-xl font-bold text-slate-800">Word Pattern</h1>
        </div>
        <a href="https://importsource.github.io/leetmotion/" target="_blank" class="text-indigo-600 hover:text-indigo-800 font-medium flex items-center gap-2 hover:underline">
            <span>LeetMotion Home</span>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M15 2a1 1 0 0 0-1-1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2zM0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm5.854 8.803a.5.5 0 1 1-.708-.707L9.243 6H3.5a.5.5 0 1 1 0-1h5.743L5.146 4.354a.5.5 0 1 1 .708-.708l5 5a.5.5 0 0 1 0 .708l-5 5z"/>
            </svg>
        </a>
    </nav>

    <!-- Main Content -->
    <main class="flex-grow p-4 md:p-8 max-w-7xl mx-auto w-full grid grid-cols-1 lg:grid-cols-3 gap-6">

        <!-- Left Column: Controls & Input -->
        <div class="lg:col-span-1 space-y-6">
            <!-- Inputs Card -->
            <div class="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <h2 class="text-lg font-semibold mb-4 text-slate-800">Configuration</h2>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-slate-600 mb-1">Pattern</label>
                        <input type="text" id="patternInput" value="abba" class="w-full px-4 py-2 rounded-lg border border-slate-300 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition font-mono tracking-widest uppercase" placeholder="e.g. abba">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-600 mb-1">String (Words)</label>
                        <input type="text" id="stringInput" value="dog cat cat dog" class="w-full px-4 py-2 rounded-lg border border-slate-300 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition" placeholder="e.g. dog cat cat dog">
                    </div>
                    
                    <div class="flex gap-2 pt-2">
                        <button id="resetBtn" class="flex-1 bg-slate-100 hover:bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-lg transition">
                            Reset
                        </button>
                        <button id="startBtn" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition shadow-md shadow-indigo-200">
                            Start
                        </button>
                    </div>
                </div>
            </div>

            <!-- Controls Card -->
            <div class="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                <h2 class="text-lg font-semibold mb-4 text-slate-800">Controls</h2>
                <div class="flex gap-3 mb-4">
                    <button id="prevBtn" class="flex-1 border border-slate-300 hover:bg-slate-50 text-slate-600 font-medium py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">
                        < Back
                    </button>
                    <button id="nextBtn" class="flex-1 bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border border-indigo-200 font-medium py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">
                        Next >
                    </button>
                </div>
                <button id="autoPlayBtn" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-3 px-4 rounded-lg transition flex items-center justify-center gap-2 shadow-md shadow-emerald-200">
                    <span id="playIcon">▶</span> <span id="playText">Auto Play</span>
                </button>
                <div class="mt-4 flex items-center gap-2">
                    <label class="text-sm text-slate-500">Speed:</label>
                    <input type="range" id="speedRange" min="100" max="2000" value="1000" class="flex-grow h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600">
                </div>
            </div>

            <!-- Log Card -->
            <div class="bg-slate-900 rounded-xl shadow-lg p-6 text-slate-200 font-mono text-sm overflow-hidden flex flex-col h-64">
                <h3 class="text-slate-400 text-xs font-bold uppercase tracking-wider mb-2 border-b border-slate-700 pb-2">Execution Log</h3>
                <div id="logContainer" class="flex-grow overflow-y-auto space-y-2 pr-2 scrollbar-thin scrollbar-thumb-slate-600 scrollbar-track-transparent">
                    <div class="text-slate-500 italic">Ready to start...</div>
                </div>
            </div>
        </div>

        <!-- Right Column: Visualization -->
        <div class="lg:col-span-2 space-y-6">
            
            <!-- Result Banner -->
            <div id="resultBanner" class="hidden rounded-xl p-4 text-center font-bold text-lg shadow-sm transition-all-300">
                <!-- Content injected via JS -->
            </div>

            <!-- Arrays Visualization -->
            <div class="bg-white rounded-xl shadow-sm border border-slate-200 p-6 overflow-x-auto">
                <h3 class="text-sm font-bold text-slate-500 uppercase tracking-wider mb-6">Iteration Process</h3>
                
                <div class="min-w-[500px]">
                    <!-- Pattern Row -->
                    <div class="flex items-center mb-2">
                        <div class="w-24 text-right font-mono text-sm text-slate-500 mr-4 font-bold">Pattern</div>
                        <div id="patternRow" class="flex gap-2">
                            <!-- Pattern Boxes -->
                        </div>
                    </div>

                    <!-- Indices -->
                    <div class="flex items-center mb-2">
                         <div class="w-24 text-right mr-4"></div>
                         <div id="indicesRow" class="flex gap-2 h-6">
                            <!-- Index markers -->
                         </div>
                    </div>

                    <!-- Words Row -->
                    <div class="flex items-center">
                        <div class="w-24 text-right font-mono text-sm text-slate-500 mr-4 font-bold">Words</div>
                        <div id="wordsRow" class="flex gap-2">
                            <!-- Word Boxes -->
                        </div>
                    </div>
                </div>
                
                <div id="statusMessage" class="mt-8 text-center text-lg font-medium text-slate-700 h-8 transition-all-300">
                    <!-- Status Text -->
                </div>
            </div>

            <!-- HashMaps Visualization -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                
                <!-- Map 1: Char -> Word -->
                <div class="bg-white rounded-xl shadow-sm border border-slate-200 p-6 relative overflow-hidden">
                    <div class="absolute top-0 right-0 p-2 opacity-10">
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="currentColor"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/></svg>
                    </div>
                    <h3 class="text-sm font-bold text-indigo-600 uppercase tracking-wider mb-4 border-b border-slate-100 pb-2">
                        Map 1: Char <span class="text-slate-400">→</span> Word
                    </h3>
                    <div class="overflow-y-auto h-48 pr-2">
                        <table class="w-full text-sm">
                            <thead class="text-xs text-slate-400 uppercase text-left">
                                <tr><th class="pb-2">Key (Char)</th><th class="pb-2">Value (Word)</th></tr>
                            </thead>
                            <tbody id="map1Body" class="text-slate-700">
                                <!-- Map Entries -->
                            </tbody>
                        </table>
                        <div id="map1Empty" class="text-center text-slate-400 py-8 text-sm italic">Map is empty</div>
                    </div>
                </div>

                <!-- Map 2: Word -> Char -->
                <div class="bg-white rounded-xl shadow-sm border border-slate-200 p-6 relative overflow-hidden">
                    <div class="absolute top-0 right-0 p-2 opacity-10">
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="currentColor"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"/></svg>
                    </div>
                    <h3 class="text-sm font-bold text-emerald-600 uppercase tracking-wider mb-4 border-b border-slate-100 pb-2">
                        Map 2: Word <span class="text-slate-400">→</span> Char
                    </h3>
                     <div class="overflow-y-auto h-48 pr-2">
                        <table class="w-full text-sm">
                            <thead class="text-xs text-slate-400 uppercase text-left">
                                <tr><th class="pb-2">Key (Word)</th><th class="pb-2">Value (Char)</th></tr>
                            </thead>
                            <tbody id="map2Body" class="text-slate-700">
                                <!-- Map Entries -->
                            </tbody>
                        </table>
                        <div id="map2Empty" class="text-center text-slate-400 py-8 text-sm italic">Map is empty</div>
                    </div>
                </div>

            </div>
        </div>
    </main>

    <!-- JS Logic -->
    <script>
        // State Management
        let state = {
            pattern: "",
            words: [],
            map1: new Map(), // Char -> Word
            map2: new Map(), // Word -> Char
            currentIndex: -1,
            isFinished: false,
            result: null, // true/false
            history: [], // store snapshots for "Back" functionality
            stepGenerator: null,
            isPlaying: false,
            playbackSpeed: 1000,
            timerId: null
        };

        // DOM Elements
        const els = {
            patternInput: document.getElementById('patternInput'),
            stringInput: document.getElementById('stringInput'),
            startBtn: document.getElementById('startBtn'),
            resetBtn: document.getElementById('resetBtn'),
            prevBtn: document.getElementById('prevBtn'),
            nextBtn: document.getElementById('nextBtn'),
            autoPlayBtn: document.getElementById('autoPlayBtn'),
            speedRange: document.getElementById('speedRange'),
            playIcon: document.getElementById('playIcon'),
            playText: document.getElementById('playText'),
            logContainer: document.getElementById('logContainer'),
            patternRow: document.getElementById('patternRow'),
            wordsRow: document.getElementById('wordsRow'),
            indicesRow: document.getElementById('indicesRow'),
            statusMessage: document.getElementById('statusMessage'),
            map1Body: document.getElementById('map1Body'),
            map2Body: document.getElementById('map2Body'),
            map1Empty: document.getElementById('map1Empty'),
            map2Empty: document.getElementById('map2Empty'),
            resultBanner: document.getElementById('resultBanner')
        };

        // Algorithm Generator
        function* wordPatternAlgo(pattern, s) {
            const words = s.trim().split(/\s+/);
            
            yield { 
                type: 'INIT', 
                msg: 'Splitting input string into words...', 
                pattern, 
                words, 
                idx: -1 
            };

            if (pattern.length !== words.length) {
                yield { 
                    type: 'ERROR', 
                    msg: `Length mismatch! Pattern length (${pattern.length}) ≠ Words count (${words.length}).`, 
                    pattern, 
                    words, 
                    idx: -1,
                    result: false 
                };
                return false;
            }

            yield { 
                type: 'CHECK_LENGTH', 
                msg: 'Lengths match. Starting iteration...', 
                pattern, 
                words, 
                idx: -1 
            };

            const map1 = new Map();
            const map2 = new Map();

            for (let i = 0; i < pattern.length; i++) {
                const char = pattern[i];
                const word = words[i];

                // Step: Focus on index
                yield {
                    type: 'FOCUS',
                    msg: `Checking index ${i}: Pattern '${char}' vs Word '${word}'`,
                    pattern, words, idx: i, map1: new Map(map1), map2: new Map(map2)
                };

                // Check Map 1
                if (map1.has(char)) {
                    const expected = map1.get(char);
                    if (expected !== word) {
                        yield {
                            type: 'ERROR',
                            msg: `Conflict in Map 1! '${char}' maps to '${expected}', but found '${word}'.`,
                            pattern, words, idx: i, map1: new Map(map1), map2: new Map(map2),
                            result: false,
                            highlight: 'map1'
                        };
                        return false;
                    } else {
                        yield {
                            type: 'MATCH_MAP1',
                            msg: `Map 1 check: '${char}' correctly maps to existing '${word}'.`,
                            pattern, words, idx: i, map1: new Map(map1), map2: new Map(map2)
                        };
                    }
                } else {
                    map1.set(char, word);
                    yield {
                        type: 'ADD_MAP1',
                        msg: `Adding to Map 1: '${char}' → '${word}'`,
                        pattern, words, idx: i, map1: new Map(map1), map2: new Map(map2)
                    };
                }

                // Check Map 2
                if (map2.has(word)) {
                    const expected = map2.get(word);
                    if (expected !== char) {
                         yield {
                            type: 'ERROR',
                            msg: `Conflict in Map 2! '${word}' maps to '${expected}', but found '${char}'.`,
                            pattern, words, idx: i, map1: new Map(map1), map2: new Map(map2),
                            result: false,
                            highlight: 'map2'
                        };
                        return false;
                    } else {
                        yield {
                            type: 'MATCH_MAP2',
                            msg: `Map 2 check: '${word}' correctly maps back to '${char}'.`,
                            pattern, words, idx: i, map1: new Map(map1), map2: new Map(map2)
                        };
                    }
                } else {
                    map2.set(word, char);
                    yield {
                        type: 'ADD_MAP2',
                        msg: `Adding to Map 2: '${word}' → '${char}'`,
                        pattern, words, idx: i, map1: new Map(map1), map2: new Map(map2)
                    };
                }
            }

            yield {
                type: 'SUCCESS',
                msg: 'All checks passed! The pattern matches.',
                pattern, words, idx: pattern.length - 1,
                map1: new Map(map1), map2: new Map(map2),
                result: true
            };
            return true;
        }

        // Render Functions
        function render(snapshot) {
            // Update inputs disabled state
            const processing = snapshot.type !== 'INIT' && !snapshot.result;
            
            // Render Arrays
            renderArrays(snapshot);

            // Render Maps
            if (snapshot.map1) renderMap(els.map1Body, els.map1Empty, snapshot.map1, 'char');
            if (snapshot.map2) renderMap(els.map2Body, els.map2Empty, snapshot.map2, 'word');

            // Log
            if (snapshot.msg) addLog(snapshot.msg, snapshot.type);

            // Status
            els.statusMessage.textContent = snapshot.msg;

            // Result Banner
            if (snapshot.hasOwnProperty('result')) {
                els.resultBanner.classList.remove('hidden');
                if (snapshot.result) {
                    els.resultBanner.className = "mb-6 rounded-xl p-4 text-center font-bold text-lg shadow-sm bg-green-100 text-green-800 border border-green-200 cell-appear";
                    els.resultBanner.innerHTML = "✅ TRUE: Pattern matches string.";
                } else {
                    els.resultBanner.className = "mb-6 rounded-xl p-4 text-center font-bold text-lg shadow-sm bg-red-100 text-red-800 border border-red-200 cell-appear";
                    els.resultBanner.innerHTML = "❌ FALSE: Pattern does not match string.";
                }
                stopAutoPlay();
            } else {
                els.resultBanner.classList.add('hidden');
            }
        }

        function renderArrays(snapshot) {
            const { pattern, words, idx, type } = snapshot;
            
            // Clear
            els.patternRow.innerHTML = '';
            els.wordsRow.innerHTML = '';
            els.indicesRow.innerHTML = '';

            // Render Pattern
            for (let i = 0; i < pattern.length; i++) {
                const isActive = i === idx;
                const isPast = i < idx || (snapshot.result && idx === pattern.length - 1);
                
                const box = document.createElement('div');
                box.className = `w-12 h-12 flex items-center justify-center rounded-lg border-2 font-mono text-lg font-bold transition-all-300 ${
                    isActive ? 'border-indigo-600 bg-indigo-50 text-indigo-700 scale-110 shadow-lg ring-2 ring-indigo-200' :
                    isPast ? 'border-slate-300 bg-slate-50 text-slate-400' :
                    'border-slate-200 bg-white text-slate-800'
                }`;
                if(type === 'ERROR' && i === idx) {
                    box.className = `w-12 h-12 flex items-center justify-center rounded-lg border-2 font-mono text-lg font-bold border-red-500 bg-red-50 text-red-700 shadow-lg`;
                }
                box.textContent = pattern[i];
                els.patternRow.appendChild(box);
            }

            // Render Words
            for (let i = 0; i < words.length; i++) {
                const isActive = i === idx;
                const isPast = i < idx || (snapshot.result && idx === words.length - 1);

                const box = document.createElement('div');
                box.className = `h-12 px-3 flex items-center justify-center rounded-lg border-2 font-medium text-sm transition-all-300 min-w-[3rem] ${
                    isActive ? 'border-indigo-600 bg-indigo-50 text-indigo-700 scale-105 shadow-lg ring-2 ring-indigo-200' :
                    isPast ? 'border-slate-300 bg-slate-50 text-slate-400' :
                    'border-slate-200 bg-white text-slate-800'
                }`;
                 if(type === 'ERROR' && i === idx) {
                    box.className = `h-12 px-3 flex items-center justify-center rounded-lg border-2 font-medium text-sm border-red-500 bg-red-50 text-red-700 shadow-lg`;
                }
                box.textContent = words[i];
                els.wordsRow.appendChild(box);
            }

            // Indices
            const maxLen = Math.max(pattern.length, words.length);
            for(let i=0; i<maxLen; i++) {
                const marker = document.createElement('div');
                marker.className = `w-12 flex justify-center text-xs text-slate-400 font-mono transition-all-300 ${i === idx ? 'text-indigo-600 font-bold scale-110' : ''}`;
                marker.textContent = i;
                // Just using w-12 for alignment, this is a rough approximation if words are different widths, 
                // but since we are using flex gap, we might need to match widths dynamically.
                // For simplicity in vanilla JS, we'll try to match the width of the pattern box primarily since it's fixed.
                // Actually, let's just make the indices absolute or align them better. 
                // For this visualization, centering the index under the pattern is enough.
                els.indicesRow.appendChild(marker);
            }
        }

        function renderMap(tbody, emptyMsg, map, type) {
            tbody.innerHTML = '';
            if (map.size === 0) {
                emptyMsg.style.display = 'block';
            } else {
                emptyMsg.style.display = 'none';
                map.forEach((val, key) => {
                    const row = document.createElement('tr');
                    row.className = "border-b border-slate-50 last:border-0 cell-appear";
                    
                    const kCell = document.createElement('td');
                    kCell.className = "py-2 px-1 font-mono font-bold text-indigo-700";
                    kCell.textContent = key;
                    
                    const vCell = document.createElement('td');
                    vCell.className = "py-2 px-1 font-medium";
                    vCell.textContent = val;

                    row.appendChild(kCell);
                    row.appendChild(vCell);
                    tbody.prepend(row); // Newest top
                });
            }
        }

        function addLog(msg, type) {
            const entry = document.createElement('div');
            let colorClass = "text-slate-300";
            if (type === 'ERROR') colorClass = "text-red-400 font-bold";
            if (type === 'SUCCESS') colorClass = "text-green-400 font-bold";
            if (type.includes('ADD')) colorClass = "text-blue-300";
            
            entry.className = `py-1 border-b border-slate-800 last:border-0 ${colorClass} text-xs md:text-sm font-mono`;
            
            const time = new Date().toLocaleTimeString([], { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
            entry.innerHTML = `<span class="opacity-50 mr-2">[${time}]</span> ${msg}`;
            
            els.logContainer.appendChild(entry);
            els.logContainer.scrollTop = els.logContainer.scrollHeight;
        }

        // Logic Control
        function init() {
            state.pattern = els.patternInput.value.trim();
            state.words = els.stringInput.value.trim().split(/\s+/);
            state.stepGenerator = wordPatternAlgo(state.pattern, els.stringInput.value);
            state.history = [];
            state.isFinished = false;
            
            // Reset UI
            els.logContainer.innerHTML = '';
            els.statusMessage.textContent = "Ready to start...";
            els.resultBanner.classList.add('hidden');
            els.map1Body.innerHTML = '';
            els.map2Body.innerHTML = '';
            els.map1Empty.style.display = 'block';
            els.map2Empty.style.display = 'block';
            
            // Render initial state
            renderArrays({ pattern: state.pattern, words: state.words, idx: -1, type: 'INIT' });

            addLog("Initialization complete. Press Start or Next.", "INIT");
            
            enableInput(false);
            els.startBtn.classList.add('hidden');
            els.resetBtn.classList.remove('hidden');
        }

        function nextStep() {
            if (state.isFinished) return;

            const { value, done } = state.stepGenerator.next();
            
            if (done) {
                state.isFinished = true;
                stopAutoPlay();
                return;
            }

            state.history.push(value);
            render(value);

            if (value.result !== undefined) {
                state.isFinished = true;
            }
        }

        function prevStep() {
            if (state.history.length <= 1) return; // Can't go back past start
            state.history.pop(); // Remove current
            const prev = state.history[state.history.length - 1];
            
            // Re-instantiate generator is hard, so we just replay history visually
            // Ideally we'd keep full state snapshots, but for this simple app, 
            // the generator yields full state maps.
            render(prev);
            state.isFinished = false;
        }

        function enableInput(enable) {
            els.patternInput.disabled = !enable;
            els.stringInput.disabled = !enable;
            els.prevBtn.disabled = enable;
            els.nextBtn.disabled = enable;
            els.autoPlayBtn.disabled = enable;
        }

        function toggleAutoPlay() {
            if (state.isPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        function startAutoPlay() {
            if(state.isFinished) return;
            state.isPlaying = true;
            els.playText.textContent = "Pause";
            els.playIcon.textContent = "⏸";
            els.autoPlayBtn.classList.remove('bg-emerald-600', 'hover:bg-emerald-700');
            els.autoPlayBtn.classList.add('bg-amber-500', 'hover:bg-amber-600');
            
            // Execute immediately then interval
            nextStep();
            state.timerId = setInterval(() => {
                if(state.isFinished) {
                    stopAutoPlay();
                } else {
                    nextStep();
                }
            }, state.playbackSpeed);
        }

        function stopAutoPlay() {
            state.isPlaying = false;
            els.playText.textContent = "Auto Play";
            els.playIcon.textContent = "▶";
            els.autoPlayBtn.classList.add('bg-emerald-600', 'hover:bg-emerald-700');
            els.autoPlayBtn.classList.remove('bg-amber-500', 'hover:bg-amber-600');
            clearInterval(state.timerId);
        }

        function reset() {
            stopAutoPlay();
            state.stepGenerator = null;
            state.history = [];
            state.isFinished = false;
            
            els.logContainer.innerHTML = '';
            els.statusMessage.textContent = "";
            els.resultBanner.classList.add('hidden');
            els.map1Body.innerHTML = '';
            els.map2Body.innerHTML = '';
            els.map1Empty.style.display = 'block';
            els.map2Empty.style.display = 'block';
            els.patternRow.innerHTML = '';
            els.wordsRow.innerHTML = '';
            els.indicesRow.innerHTML = '';

            els.startBtn.classList.remove('hidden');
            els.resetBtn.classList.add('hidden');
            
            enableInput(true);
            
            // disable controls
            els.prevBtn.disabled = true;
            els.nextBtn.disabled = true;
            els.autoPlayBtn.disabled = true;
        }

        // Event Listeners
        els.startBtn.addEventListener('click', () => {
            init();
            nextStep(); // Show first state
        });
        
        els.resetBtn.addEventListener('click', reset);
        
        els.nextBtn.addEventListener('click', () => {
            stopAutoPlay();
            nextStep();
        });

        els.prevBtn.addEventListener('click', () => {
            stopAutoPlay();
            prevStep();
        });

        els.autoPlayBtn.addEventListener('click', toggleAutoPlay);

        els.speedRange.addEventListener('input', (e) => {
            state.playbackSpeed = 2100 - e.target.value; // Invert so right is faster
            if (state.isPlaying) {
                stopAutoPlay();
                startAutoPlay();
            }
        });

        // Initialize state on load
        reset();

    </script>
</body>
</html>